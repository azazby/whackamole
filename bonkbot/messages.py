from dataclasses import dataclass
from typing import List, Optional, Literal
import numpy as np
# Drake dependencies
from pydrake.math import RigidTransform
from pydrake.trajectories import PiecewisePolynomial

# --- Basic type aliases -------------------------------------------------------
Vector3 = np.ndarray       # shape (3,)
JointVector = np.ndarray   # shape (n,)
Time = float               # seconds representing timestep of simulation


# --- Perception-related messages ---------------------------------------------
@dataclass(frozen=True)
class MoleDetection:
    """
    Info about a single mole at a given time.
    All poses are expressed in the world frame W.
    """
    mole_id: int
    pose_W: RigidTransform                      # pose of mole center or hit point
    is_up: bool                                 # True if mole is considered 'up'
    time_up_remaining: Optional[float] = None   # estimate time (s) remaining until mole goes down, if known

@dataclass(frozen=True)
class PerceptionOutput:
    """
    Output of the perception module at one time step.
    """
    timestamp: Time
    detections: List[MoleDetection]

# --- Strategy-related messages -----------------------------------------------
StrategyMode = Literal[
    "idle",                 # no target selected
    "plan_to_prehit",       # want a prehit plan for a target
    "ready_to_hit",         # at prehit; ready to generate hit plan
    "cancel_current",       # abandon current target
]
PostHitBehavior = Literal[
    "chain_next_target",    # immediately look for and go to next mole
    "return_to_ready",      # go to a predefined ready pose before next target
]

@dataclass(frozen=True)
class StrategyOutput:
    """
    Decision made by game strategy: which mole to hit next and how.
    """
    timestamp: Time
    mode: StrategyMode
    target_mole_id: Optional[int] = None
    target_prehit_pose_W: Optional[object] = None                  # desired hammer/EE pose just above the mole before hitting
    hit_direction_W: Optional[Vector3] = None               # vector in world frame indicating desired hit direction
    post_hit_behavior: PostHitBehavior = "return_to_ready"  # what to do after hit completes
    hit_deadline: Optional[Time] = None                     # optional deadline by which we would like the hit to happen (world time)
                                                            # supervisor can use this to prioritize targets or cancel if deadline is missed


# --- Planning-related messages -----------------------------------------------
@dataclass(frozen=True)
class JointTrajectory:
    """
    Generic joint-space trajectory.
    Wraps a Drake PiecewisePolynomial plus meta info.
    """
    q_traj: PiecewisePolynomial  # q(t): R -> R^n
    start_time: Time             # when this trajectory is intended to start
    duration: Time               # total duration (s)

    def end_time(self) -> Time:
        return self.start_time + self.duration


@dataclass(frozen=True)
class PrehitPlan:
    """
    Plan to move from current configuration to prehit pose.
    Generated by the prehit planner.
    """
    target_mole_id: int
    traj: JointTrajectory
    # optional: record the goal config and/or EE pose for debugging
    q_goal: Optional[JointVector] = None
    target_prehit_pose_W: Optional[RigidTransform] = None


@dataclass(frozen=True)
class HitPlan:
    """
    Short trajectory that executes the actual hit motion and return.
    """
    target_mole_id: int
    traj: JointTrajectory
    # optional: impact point and direction used to build this hit
    impact_pose_W: Optional[RigidTransform] = None
    hit_direction_W: Optional[Vector3] = None


# --- Controller-related messages ---------------------------------------------
ControllerMode = Literal[
    "idle",
    "track_prehit",
    "track_hit",
    "track_return",
]

@dataclass(frozen=True)
class ControllerCommand:
    """
    Command from the supervisor to the trajectory controller.
    """
    timestamp: Time
    mode: ControllerMode
    traj: Optional[JointTrajectory] = None

@dataclass(frozen=True)
class ControllerStatus:
    """
    Feedback from the controller to the supervisor.
    """
    timestamp: Time
    mode: ControllerMode
    executing_traj: bool
    traj_start_time: Optional[Time] = None
    traj_end_time: Optional[Time] = None
    traj_complete: bool = False         # True if we believe the current traj has reached its goal.


# --- Supervisor-related messages --------------------------------------
SupervisorState = Literal[
    "idle",
    "planning_prehit",
    "executing_prehit",
    "ready_to_hit",
    "executing_hit",
    "returning_home",
]

@dataclass(frozen=True)
class HitEvent:
    """
    Discrete event: a hit attempt and whether it was successful.
    """
    timestamp: Time
    mole_id: int
    success: bool
    # optional: how 'early/late' the hit was vs. mole up window.
    timing_error: Optional[float] = None


@dataclass(frozen=True)
class GameState:
    """
    High-level snapshot for logging / monitoring.
    """
    timestamp: Time
    supervisor_state: SupervisorState
    score: int
    total_attempts: int
    last_hit: Optional[HitEvent] = None